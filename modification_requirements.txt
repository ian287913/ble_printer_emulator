===============================================================================
BlueZ 5.82 額外修改需求 — 解決 POS App 連線失敗問題
===============================================================================

日期：2026-02-20
依據：btmon 封包分析（logs/btmon_init.log、logs/btmon_try_connect.log）
狀態：✅ 已完成並驗證通過

===============================================================================
1. 問題描述
===============================================================================

POS App 連線到模擬器後，數秒內顯示連線成功，隨後轉為連線失敗，無法列印。

===============================================================================
2. 根因分析（依 btmon 封包追蹤）
===============================================================================

【問題 A】BlueZ 主動發送 SMP Security Request（核心問題）

  btmon_try_connect.log 封包 #10：
  ┌─────────────────────────────────────────────────────────────┐
  │ < ACL Data TX: Handle 64 flags 0x00 dlen 6                 │
  │     SMP: Security Request (0x0b) len 1                     │
  │       Auth requirement: Bonding, No MITM, Legacy (0x01)    │
  └─────────────────────────────────────────────────────────────┘

  BLE 連線建立後，BlueZ 立刻向客戶端發送 SMP Security Request。
  真正的 BT-B36 印表機不會發送此請求，它完全不需要配對即可操作。

  連鎖反應：
  1) 手機端收到 Security Request → 認為需要配對
  2) 手機發送 Pairing Request（封包 #154）：
       - IO capability: KeyboardDisplay (0x04)
       - Auth requirement: Bonding, MITM, SC, CT2 (0x2d)
  3) Pi 回覆 Pairing Response（封包 #155）：
       - IO capability: NoInputNoOutput (0x03)
       - Auth requirement: Bonding, MITM, Legacy (0x05)
  4) SC (Secure Connections) vs Legacy 不相容 → 配對失敗 → 連線斷開

  結論：只要阻止 BlueZ 發送 SMP Security Request，手機端就不會嘗試配對，
        連線可以保持在無安全層的狀態下正常運作。

【問題 B】bondable 被 bluetoothd 覆蓋（次要問題）

  btmon_init.log 中的時序：
  1) test_gatt.py 呼叫 btmgmt bondable off → 成功關閉 bondable
  2) bluetoothd 內部邏輯立刻又執行 Set Bondable: Enabled (0x01)

  這導致 bondable 實際上永遠是開啟的，腳本的設定被 daemon 覆蓋。

  根因：src/adapter.c 的 adapter_set_io_capability() 函式中，
  當 agent 註冊時（io_cap 為有效值），會重新啟用 bondable：
    if (!(adapter->current_settings & MGMT_SETTING_BONDABLE))
        set_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);

===============================================================================
3. 修改內容（✅ 已完成）
===============================================================================

【修改 6】阻止安全等級提升，防止 SMP Security Request（✅ 已完成）
---------------------------------------------------------------------------

  檔案：src/device.c
  函式：device_attach_att()（約第 5943 行）
  方式：用 #if 0 停用安全等級提升邏輯

  原始碼：
    if (sec_level == BT_IO_SEC_LOW && dev->le_state.paired) {
        DBG("Elevating security level since LTK is available");
        sec_level = BT_IO_SEC_MEDIUM;
        bt_io_set(io, &gerr, BT_IO_OPT_SEC_LEVEL, sec_level,
                            BT_IO_OPT_INVALID);
        ...
    }

  修改後：
    /* 跳過安全等級提升，避免觸發 SMP Security Request。
     * 原本會對已配對裝置提升至 BT_IO_SEC_MEDIUM，導致 kernel
     * 發送 SMP Security Request (0x0b)，使 POS App 配對失敗。
     */
    #if 0
    if (sec_level == BT_IO_SEC_LOW && dev->le_state.paired) {
        ...
    }
    #endif

  原理：device_attach_att() 在 BLE 連線建立時被呼叫。若裝置曾經配對
  （dev->le_state.paired），會透過 bt_io_set() 直接對 L2CAP socket
  呼叫 setsockopt(BT_SECURITY, MEDIUM)，觸發 kernel 發送 SMP
  Security Request (0x0b)。此路徑繞過了已修改的 bt_att_set_security()，
  因此需要在此處額外攔截。


【修改 7】防止 bluetoothd 覆蓋 bondable 設定（✅ 已完成）
---------------------------------------------------------------------------

  檔案：src/adapter.c
  函式：adapter_set_io_capability()（約第 9077 行）
  方式：用 #if 0 停用 agent 註冊時重新啟用 bondable 的邏輯

  原始碼：
    if (!(adapter->current_settings & MGMT_SETTING_BONDABLE))
        set_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);

  修改後：
    /* 不再於 agent 註冊時重新啟用 bondable，
     * 避免覆蓋 btmgmt bondable off 的設定。
     */
    #if 0
    if (!(adapter->current_settings & MGMT_SETTING_BONDABLE))
        set_mode(adapter, MGMT_OP_SET_BONDABLE, 0x01);
    #endif

  原理：當 D-Bus agent 註冊時，adapter_set_io_capability() 被呼叫，
  若 btd_opts.pairable 為 false（預設值）且 bondable 未啟用，
  會自動重新啟用 bondable，覆蓋 test_gatt.py 透過 btmgmt 設定的
  bondable off。

===============================================================================
4. 所有已完成的修改總覽（共 7 項）
===============================================================================

  修改 1-5（參考 bluez-modification-guide.md）：
  1. src/shared/att.c — bt_att_set_security() 直接返回 true
  2. src/shared/gatt-server.c — check_permissions() 返回 0
  3. src/adapter.c — IO Capability 設為 NoInputNoOutput (0x03)
  4. src/adapter.c — 註解掉 MGMT_SETTING_SECURE_CONN
  5. src/shared/att.c — chan->sec_level = BT_ATT_SECURITY_LOW

  修改 6-7（本文件）：
  6. src/device.c — 停用 device_attach_att() 安全等級提升
  7. src/adapter.c — 停用 agent 註冊時重新啟用 bondable

  修改 1-5 跳過了 GATT 層的權限檢查和安全連線。
  修改 6-7 阻止了 SMP 層主動發起 Security Request 並防止 bondable 被覆蓋。

===============================================================================
5. 測試結果（✅ 通過）
===============================================================================

  驗證日期：2026-02-20

  1. 重新編譯安裝 BlueZ：
       cd ~/bluez-5.82 && make -j4 && sudo make install
       sudo systemctl daemon-reload && sudo systemctl restart bluetooth

  2. 啟動模擬器：
       sudo python3 code/test_gatt.py

  3. 開啟 btmon 監控：
       sudo btmon | tee logs/btmon_test.log

  4. 用 POS App 連線，確認：
     [✅] btmon 中不出現 "SMP: Security Request"
     [✅] btmon 中不出現 "SMP: Pairing Request / Pairing Response"
     [✅] App 顯示連線成功且維持連線
     [✅] App 能正常發送列印指令

===============================================================================